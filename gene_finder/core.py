"""Utilities Functions"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_core.ipynb.

# %% auto 0
__all__ = ['retrieve_and_save_sequence']

# %% ../nbs/00_core.ipynb 2
from nbdev.showdoc import *
import subprocess
from pathlib import Path
from typing import Union, Optional
from Bio import SeqIO
from Bio.SeqRecord import SeqRecord
from Bio.Seq import Seq

# %% ../nbs/00_core.ipynb 6
def retrieve_and_save_sequence(
    fasta_file: Union[str, Path],
    fasta_id: str,
    start: int,
    end: int,
    output_file: Union[str, Path]
) -> Optional[str]:
    """
    Retrieve a subsequence from a FASTA file and save it to a new file.
    
    Args:
        fasta_file: Path to the input FASTA file.
        fasta_id: The ID of the sequence to retrieve.
        start: The starting position (1-based, inclusive).
        end: The ending position (1-based, inclusive).
        output_file: Path to the output FASTA file.
    
    Returns:
        str: Success message with output file path, or None if error occurs.
    
    Raises:
        ValueError: If fasta_id not found, or if start/end positions are invalid.
        FileNotFoundError: If input FASTA file doesn't exist.
    
    Example:
        >>> retrieve_and_save_sequence('genome.fasta', 'chr1', 100, 200, 'output.fasta')
        'Sequence saved to output.fasta'
    """
    # Convert to Path objects for better path handling
    fasta_file = Path(fasta_file)
    output_file = Path(output_file)
    
    try:
        # Validate input file exists
        if not fasta_file.exists():
            raise FileNotFoundError(f"Input file not found: {fasta_file}")
        
        # Validate coordinates
        if start < 1 or end < 1:
            raise ValueError(f"Coordinates must be >= 1 (got start={start}, end={end})")
        if start > end:
            raise ValueError(f"Start position ({start}) must be <= end position ({end})")
        
        # Search for the sequence
        for record in SeqIO.parse(fasta_file, "fasta"):
            if record.id == fasta_id:
                # Validate coordinates against sequence length
                if end > len(record.seq):
                    raise ValueError(
                        f"End position ({end}) exceeds sequence length ({len(record.seq)})"
                    )
                
                # Extract subsequence (convert to 0-based indexing)
                subsequence = record.seq[start - 1:end]
                
                # Create new record with descriptive ID
                new_record = SeqRecord(
                    subsequence,
                    id=f"{fasta_id}_{start}_{end}",
                    description=f"Extracted from {fasta_id}, positions {start}-{end}"
                )
                
                # Write to output file
                with open(output_file, "w") as output_handle:
                    SeqIO.write(new_record, output_handle, "fasta")
                
                return f"Sequence saved to {output_file}"
        
        # Sequence ID not found
        raise ValueError(f"FASTA ID '{fasta_id}' not found in {fasta_file}")
    
    except Exception as e:
        print(f"Error extracting sequence: {e}")
        return None
